import { Matrix, Quaternion, TmpVectors, Vector3 } from "../../../../Maths/math.vector.js";
import { FlowGraphBinaryOperationBlock } from "../flowGraphBinaryOperationBlock.js";
import { RichTypeAny, RichTypeMatrix, RichTypeNumber, RichTypeQuaternion, RichTypeVector3 } from "../../../flowGraphRichTypes.js";
import { FlowGraphUnaryOperationBlock } from "../flowGraphUnaryOperationBlock.js";
import { FlowGraphBlock } from "../../../flowGraphBlock.js";
/**
 * Adds two matrices together.
 * @experimental
 */
export class FlowGraphAddMatrixBlock extends FlowGraphBinaryOperationBlock {
    constructor() {
        super(RichTypeMatrix, RichTypeMatrix, RichTypeMatrix, (left, right) => left.add(right));
    }
}
/**
 * Adds a matrix and a number together.
 * @experimental
 */
export class FlowGraphAddMatrixAndNumberBlock extends FlowGraphBinaryOperationBlock {
    constructor() {
        super(RichTypeMatrix, RichTypeNumber, RichTypeMatrix, (left, right) => {
            for (let i = 0; i < left.m.length; i++) {
                this._cachedArray[i] = left.m[i] + right;
            }
            return Matrix.FromArrayToRef(this._cachedArray, 0, this._cachedMatrix);
        });
        this._cachedArray = new Float32Array(16);
        this._cachedMatrix = Matrix.Zero();
    }
}
/**
 * Subtracts two matrices.
 * @experimental
 */
export class FlowGraphSubtractMatrixBlock extends FlowGraphBinaryOperationBlock {
    constructor() {
        super(RichTypeMatrix, RichTypeMatrix, RichTypeMatrix, (left, right) => left.addToRef(right.scaleToRef(-1, TmpVectors.Matrix[0]), this._cachedMatrix));
        this._cachedMatrix = Matrix.Zero();
    }
}
/**
 * Subtracts a matrix and a number together.
 * @experimental
 */
export class FlowGraphSubtractMatrixAndNumberBlock extends FlowGraphBinaryOperationBlock {
    constructor() {
        super(RichTypeMatrix, RichTypeNumber, RichTypeMatrix, (left, right) => {
            for (let i = 0; i < left.m.length; i++) {
                this._cachedArray[i] = left.m[i] - right;
            }
            return Matrix.FromArrayToRef(this._cachedArray, 0, this._cachedMatrix);
        });
        this._cachedArray = new Float32Array(16);
        this._cachedMatrix = Matrix.Zero();
    }
}
/**
 * Multiplies two matrices together.
 * @experimental
 */
export class FlowGraphMultiplyMatrixBlock extends FlowGraphBinaryOperationBlock {
    constructor() {
        super(RichTypeMatrix, RichTypeMatrix, RichTypeMatrix, (left, right) => left.multiplyToRef(right, this._cachedMatrix));
        this._cachedMatrix = Matrix.Zero();
    }
}
/**
 * Divides two matrices.
 * @experimental
 */
export class FlowGraphDivideMatrixBlock extends FlowGraphBinaryOperationBlock {
    constructor() {
        super(RichTypeMatrix, RichTypeMatrix, RichTypeMatrix, (left, right) => left.multiplyToRef(right.invertToRef(TmpVectors.Matrix[0]), this._cachedResultMatrix));
        this._cachedResultMatrix = Matrix.Zero();
    }
}
/**
 * Divides a matrix and a number together.
 * @experimental
 */
export class FlowGraphDivideMatrixAndNumberBlock extends FlowGraphBinaryOperationBlock {
    constructor() {
        super(RichTypeMatrix, RichTypeNumber, RichTypeMatrix, (left, right) => {
            for (let i = 0; i < left.m.length; i++) {
                this._cachedArray[i] = left.m[i] / right;
            }
            return Matrix.FromArrayToRef(this._cachedArray, 0, this._cachedMatrix);
        });
        this._cachedArray = new Float32Array(16);
        this._cachedMatrix = Matrix.Zero();
    }
}
/**
 * Scales a matrix by a number.
 * @experimental
 */
export class FlowGraphScaleMatrixBlock extends FlowGraphBinaryOperationBlock {
    constructor() {
        super(RichTypeMatrix, RichTypeNumber, RichTypeMatrix, (left, right) => left.scaleToRef(right, this._cachedMatrix));
        this._cachedMatrix = Matrix.Zero();
    }
}
/**
 * Clamps each value in a matrix between a minimum and maximum value.
 * @experimental
 */
export class FlowGraphClampMatrixBlock extends FlowGraphBlock {
    constructor() {
        super();
        this._cachedArray = new Float32Array(16);
        this._cachedMatrix = Matrix.Identity();
        this.input = this._registerDataInput("input", RichTypeMatrix);
        this.min = this._registerDataInput("min", RichTypeNumber);
        this.max = this._registerDataInput("max", RichTypeNumber);
        this.output = this._registerDataOutput("output", RichTypeMatrix);
    }
    _updateOutputs(_context) {
        const input = this.input.getValue(_context);
        const min = this.min.getValue(_context);
        const max = this.max.getValue(_context);
        for (let i = 0; i < input.m.length; i++) {
            this._cachedArray[i] = Math.min(Math.max(input.m[i], min), max);
        }
        Matrix.FromArrayToRef(this._cachedArray, 0, this._cachedMatrix);
        this.output.setValue(this._cachedMatrix, _context);
    }
}
/**
 * Decomposes a matrix into its translation, rotation and scale components.
 * @experimental
 */
export class FlowGraphDecomposeMatrixBlock extends FlowGraphBlock {
    constructor() {
        super();
        this._cachedTranslation = new Vector3();
        this._cachedRotation = new Quaternion();
        this._cachedScale = new Vector3();
        this.input = this._registerDataInput("input", RichTypeMatrix);
        this.translation = this._registerDataOutput("translation", RichTypeVector3);
        this.rotation = this._registerDataOutput("rotation", RichTypeQuaternion);
        this.scale = this._registerDataOutput("scale", RichTypeVector3);
    }
    _updateOutputs(_context) {
        const input = this.input.getValue(_context);
        input.decompose(this._cachedScale, this._cachedRotation, this._cachedTranslation);
        this.translation.setValue(this._cachedTranslation, _context);
        this.rotation.setValue(this._cachedRotation, _context);
        this.scale.setValue(this._cachedScale, _context);
    }
}
/**
 * Decomposes a matrix into its translation, rotation and scale components.
 * @experimental
 */
export class FlowGraphComposeMatrixBlock extends FlowGraphBlock {
    constructor() {
        super();
        this._cachedMatrix = new Matrix();
        this.output = this._registerDataOutput("input", RichTypeMatrix);
        this.translation = this._registerDataInput("translation", RichTypeVector3);
        this.rotation = this._registerDataInput("rotation", RichTypeQuaternion);
        this.scale = this._registerDataInput("scale", RichTypeVector3);
    }
    _updateOutputs(_context) {
        const translation = this.translation.getValue(_context);
        const rotation = this.rotation.getValue(_context);
        const scale = this.scale.getValue(_context);
        Matrix.ComposeToRef(scale, rotation, translation, this._cachedMatrix);
        this.output.setValue(this._cachedMatrix, _context);
    }
}
/**
 * Converts a quaternion to a rotation matrix.
 * @experimental
 */
export class FlowGraphQuaternionToRotationMatrixBlock extends FlowGraphUnaryOperationBlock {
    constructor() {
        super(RichTypeQuaternion, RichTypeMatrix, (value) => Matrix.FromQuaternionToRef(value, this._cachedMatrix));
        this._cachedMatrix = new Matrix();
    }
}
/**
 * Given the Transform Nodes A and B, gives the matrix required
 * to transform coordinates from A's local space to B's local space.
 */
export class FlowGraphGetTransformationMatrixBlock extends FlowGraphBinaryOperationBlock {
    constructor() {
        super(RichTypeAny, RichTypeAny, RichTypeMatrix, (left, right) => {
            const aMatrix = left.getWorldMatrix();
            const bMatrix = right.getWorldMatrix();
            const inverseB = bMatrix.invertToRef(TmpVectors.Matrix[0]);
            const result = inverseB.multiplyToRef(aMatrix, this._cachedResult);
            return result;
        });
        this._cachedResult = Matrix.Zero();
    }
}
//# sourceMappingURL=flowGraphMatrixBlocks.js.map