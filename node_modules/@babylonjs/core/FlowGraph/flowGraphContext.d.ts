import type { Scene } from "../scene";
import type { FlowGraphAsyncExecutionBlock } from "./flowGraphAsyncExecutionBlock";
import type { FlowGraphBlock } from "./flowGraphBlock";
import type { FlowGraphDataConnection } from "./flowGraphDataConnection";
import type { FlowGraphEventCoordinator } from "./flowGraphEventCoordinator";
/**
 * Construction parameters for the context.
 * @experimental
 */
export interface IFlowGraphGraphVariables {
    /**
     * The scene that the flow graph context belongs to.
     */
    readonly scene: Scene;
    /**
     * The event coordinator used by the flow graph context.
     */
    readonly eventCoordinator: FlowGraphEventCoordinator;
}
/**
 * @experimental
 * The context represents the current state and execution of the flow graph.
 * It contains both user-defined variables, which are derived from
 * a more general variable definition, and execution variables that
 * are set by the blocks.
 */
export declare class FlowGraphContext {
    /**
     * These are the variables defined by a user.
     */
    private _userVariables;
    /**
     * These are the variables set by the blocks.
     */
    private _executionVariables;
    /**
     * These are the values for the data connection points
     */
    private _connectionValues;
    /**
     * These are the variables set by the graph.
     */
    private readonly _graphVariables;
    /**
     * These are blocks that have currently pending tasks/listeners that need to be cleaned up.
     */
    private _pendingBlocks;
    constructor(params: IFlowGraphGraphVariables);
    /**
     * Check if a user-defined variable is defined.
     * @param name
     * @returns
     */
    hasVariable(name: string): boolean;
    /**
     * Set a user-defined variable.
     * @param name
     * @param value
     */
    setVariable(name: string, value: any): void;
    /**
     * Get a user-defined variable.
     * @param name
     * @returns
     */
    getVariable(name: string): any;
    private _getUniqueIdPrefixedName;
    /**
     * Set an internal execution variable
     * @internal
     * @param name
     * @param value
     */
    _setExecutionVariable(block: FlowGraphBlock, name: string, value: any): void;
    /**
     * Get an internal execution variable
     * @internal
     * @param name
     * @returns
     */
    _getExecutionVariable(block: FlowGraphBlock, name: string, defaultValue?: any): any;
    /**
     * Delete an internal execution variable
     * @internal
     * @param block
     * @param name
     */
    _deleteExecutionVariable(block: FlowGraphBlock, name: string): void;
    /**
     * Check if an internal execution variable is defined
     * @internal
     * @param block
     * @param name
     * @returns
     */
    _hasExecutionVariable(block: FlowGraphBlock, name: string): boolean;
    /**
     * Check if a connection value is defined
     * @internal
     * @param connectionPoint
     * @returns
     */
    _hasConnectionValue(connectionPoint: FlowGraphDataConnection<any>): boolean;
    /**
     * Set a connection value
     * @internal
     * @param connectionPoint
     * @param value
     */
    _setConnectionValue<T>(connectionPoint: FlowGraphDataConnection<T>, value: T): void;
    /**
     * Get a connection value
     * @internal
     * @param connectionPoint
     * @returns
     */
    _getConnectionValue<T>(connectionPoint: FlowGraphDataConnection<T>): T;
    /**
     * Get the graph set variables
     * @internal
     * @param name
     * @param value
     */
    get graphVariables(): IFlowGraphGraphVariables;
    /**
     * Add a block to the list of blocks that have pending tasks.
     * @internal
     * @param block
     */
    _addPendingBlock(block: FlowGraphAsyncExecutionBlock): void;
    /**
     * Remove a block from the list of blocks that have pending tasks.
     * @internal
     * @param block
     */
    _removePendingBlock(block: FlowGraphAsyncExecutionBlock): void;
    /**
     * Clear all pending blocks.
     * @internal
     */
    _clearPendingBlocks(): void;
}
