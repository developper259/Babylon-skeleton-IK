{"version":3,"file":"flowGraph.js","sourceRoot":"","sources":["../../../../dev/core/src/FlowGraph/flowGraph.ts"],"names":[],"mappings":"AAIA,OAAO,EAAE,4BAA4B,EAAE,MAAM,gCAAgC,CAAC;AAI9E,MAAM,CAAN,IAAY,cASX;AATD,WAAY,cAAc;IACtB;;OAEG;IACH,yDAAO,CAAA;IACP;;OAEG;IACH,yDAAO,CAAA;AACX,CAAC,EATW,cAAc,KAAd,cAAc,QASzB;AAgBD;;;;;;GAMG;AACH,MAAM,OAAO,SAAS;IAoBlB;;;OAGG;IACH,YAAmB,MAAuB;QAvB1C;;WAEG;QACI,wBAAmB,GAAiC,IAAI,4BAA4B,EAAE,CAAC;QAEtF,iBAAY,GAA0B,EAAE,CAAC;QAOzC,uBAAkB,GAAuB,EAAE,CAAC;QAEpD;;WAEG;QACH,UAAK,GAAmB,cAAc,CAAC,OAAO,CAAC;QAO3C,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC;QAC3B,IAAI,CAAC,iBAAiB,GAAG,MAAM,CAAC,gBAAgB,CAAC;QACjD,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;IAC3F,CAAC;IAED;;;OAGG;IACI,aAAa;QAChB,MAAM,OAAO,GAAG,IAAI,CAAC,mBAAmB,CAAC,eAAe,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,gBAAgB,EAAE,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC;QAC3H,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACtC,OAAO,OAAO,CAAC;IACnB,CAAC;IAED;;;;OAIG;IACI,aAAa,CAAC,KAA0B;QAC3C,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAClC,CAAC;IAED;;OAEG;IACI,KAAK;QACR,IAAI,IAAI,CAAC,KAAK,KAAK,cAAc,CAAC,OAAO,EAAE;YACvC,OAAO;SACV;QACD,IAAI,CAAC,KAAK,GAAG,cAAc,CAAC,OAAO,CAAC;QACpC,IAAI,IAAI,CAAC,kBAAkB,CAAC,MAAM,KAAK,CAAC,EAAE;YACtC,IAAI,CAAC,aAAa,EAAE,CAAC;SACxB;QACD,KAAK,MAAM,OAAO,IAAI,IAAI,CAAC,kBAAkB,EAAE;YAC3C,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,YAAY,EAAE;gBACnC,KAAK,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;aACrC;SACJ;IACL,CAAC;IAED;;OAEG;IACI,OAAO;QACV,IAAI,IAAI,CAAC,KAAK,KAAK,cAAc,CAAC,OAAO,EAAE;YACvC,OAAO;SACV;QACD,IAAI,CAAC,KAAK,GAAG,cAAc,CAAC,OAAO,CAAC;QACpC,KAAK,MAAM,OAAO,IAAI,IAAI,CAAC,kBAAkB,EAAE;YAC3C,OAAO,CAAC,mBAAmB,EAAE,CAAC;SACjC;QACD,IAAI,CAAC,kBAAkB,CAAC,MAAM,GAAG,CAAC,CAAC;QACnC,IAAI,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC;QAC7B,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC,MAAM,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC;QACnE,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC;IACtC,CAAC;CACJ","sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { FlowGraphEventBlock } from \"./flowGraphEventBlock\";\r\nimport { FlowGraphVariableDefinitions } from \"./flowGraphVariableDefinitions\";\r\nimport type { FlowGraphContext } from \"./flowGraphContext\";\r\nimport type { FlowGraphEventCoordinator } from \"./flowGraphEventCoordinator\";\r\n\r\nexport enum FlowGraphState {\r\n    /**\r\n     * The graph is stopped\r\n     */\r\n    Stopped,\r\n    /**\r\n     * The graph is running\r\n     */\r\n    Started,\r\n}\r\n\r\n/**\r\n * @experimental\r\n * Parameters used to create a flow graph.\r\n */\r\nexport interface FlowGraphParams {\r\n    /**\r\n     * The scene that the flow graph belongs to.\r\n     */\r\n    scene: Scene;\r\n    /**\r\n     * The event coordinator used by the flow graph.\r\n     */\r\n    eventCoordinator: FlowGraphEventCoordinator;\r\n}\r\n/**\r\n * @experimental\r\n * Class used to represent a flow graph.\r\n * A flow graph is a graph of blocks that can be used to create complex logic.\r\n * Blocks can be added to the graph and connected to each other.\r\n * The graph can then be started, which will init and start all of its event blocks.\r\n */\r\nexport class FlowGraph {\r\n    /**\r\n     * The variables defined for this graph\r\n     */\r\n    public variableDefinitions: FlowGraphVariableDefinitions = new FlowGraphVariableDefinitions();\r\n\r\n    private _eventBlocks: FlowGraphEventBlock[] = [];\r\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\r\n    /**\r\n     * @internal\r\n     */\r\n    public readonly _scene: Scene;\r\n    private _eventCoordinator: FlowGraphEventCoordinator;\r\n    private _executionContexts: FlowGraphContext[] = [];\r\n\r\n    /**\r\n     * The state of the graph\r\n     */\r\n    state: FlowGraphState = FlowGraphState.Stopped;\r\n\r\n    /**\r\n     * Construct a Flow Graph\r\n     * @param params construction parameters. currently only the scene\r\n     */\r\n    public constructor(params: FlowGraphParams) {\r\n        this._scene = params.scene;\r\n        this._eventCoordinator = params.eventCoordinator;\r\n        this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => this.dispose());\r\n    }\r\n\r\n    /**\r\n     * Create a context. A context represents one self contained execution for the graph, with its own variables.\r\n     * @returns the context, where you can get and set variables\r\n     */\r\n    public createContext() {\r\n        const context = this.variableDefinitions.generateContext({ scene: this._scene, eventCoordinator: this._eventCoordinator });\r\n        this._executionContexts.push(context);\r\n        return context;\r\n    }\r\n\r\n    /**\r\n     * Add an event block. When the graph is started, it will start listening to events\r\n     * from the block and execute the graph when they are triggered.\r\n     * @param block\r\n     */\r\n    public addEventBlock(block: FlowGraphEventBlock): void {\r\n        this._eventBlocks.push(block);\r\n    }\r\n\r\n    /**\r\n     * Starts the flow graph. Initializes the event blocks and starts listening to events.\r\n     */\r\n    public start() {\r\n        if (this.state === FlowGraphState.Started) {\r\n            return;\r\n        }\r\n        this.state = FlowGraphState.Started;\r\n        if (this._executionContexts.length === 0) {\r\n            this.createContext();\r\n        }\r\n        for (const context of this._executionContexts) {\r\n            for (const block of this._eventBlocks) {\r\n                block._startPendingTasks(context);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the flow graph. Cancels any pending tasks and removes all event listeners.\r\n     */\r\n    public dispose() {\r\n        if (this.state === FlowGraphState.Stopped) {\r\n            return;\r\n        }\r\n        this.state = FlowGraphState.Stopped;\r\n        for (const context of this._executionContexts) {\r\n            context._clearPendingBlocks();\r\n        }\r\n        this._executionContexts.length = 0;\r\n        this._eventBlocks.length = 0;\r\n        this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);\r\n        this._sceneDisposeObserver = null;\r\n    }\r\n}\r\n"]}